<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="Personal Page"><meta name=author content="Martin Jackson"><meta name=lang:clipboard.copy content="Copy to clipboard"><meta name=lang:clipboard.copied content="Copied to clipboard"><meta name=lang:search.language content=en><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content="No matching documents"><meta name=lang:search.result.one content="1 matching document"><meta name=lang:search.result.other content="# matching documents"><meta name=lang:search.tokenizer content=[\s\-]+><link rel="shortcut icon" href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.1, mkdocs-material-4.6.3"><title>Using the Spark Aggregator class in Scala - Martin Jackson</title><link rel=stylesheet href=../../assets/stylesheets/application.adb8469c.css><link rel=stylesheet href=../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content=#7e57c2><script src=../../assets/javascripts/modernizr.86422ebf.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../assets/fonts/material-icons.css></head> <body dir=ltr data-md-color-primary=deep-purple data-md-color-accent=cyan> <svg class=md-svg> <defs> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#using-the-spark-aggregator-class-in-scala tabindex=0 class=md-skip> Skip to content </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=../.. title="Martin Jackson" aria-label="Martin Jackson" class="md-header-nav__button md-logo"> <i class=md-icon></i> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> Martin Jackson </span> <span class=md-header-nav__topic> Using the Spark Aggregator class in Scala </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search></label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input aria-label=search name=query placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=query data-md-state=active> <label class="md-icon md-search__icon" for=__search></label> <button type=reset class="md-icon md-search__icon" data-md-component=reset tabindex=-1> &#xE5CD; </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=result> <div class=md-search-result__meta> Type to start searching </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=../.. title="Martin Jackson" class="md-nav__button md-logo"> <i class=md-icon></i> </a> Martin Jackson </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. title=Home class=md-nav__link> Home </a> </li> <li class=md-nav__item> <a href=../../resume-cv/resume-cv/ title=Resume/CV class=md-nav__link> Resume/CV </a> </li> <li class=md-nav__item> <a href=../articles/ title=Blog class=md-nav__link> Blog </a> </li> <li class=md-nav__item> <a href=../../economics/economics/ title=Economics class=md-nav__link> Economics </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#type-safe-aggregations class=md-nav__link> Type-safe Aggregations </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#what-are-they class=md-nav__link> What are they? </a> </li> <li class=md-nav__item> <a href=#when-to-use-them class=md-nav__link> When to use them </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#an-aggregator-example class=md-nav__link> An Aggregator example </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#assumptions class=md-nav__link> Assumptions </a> </li> <li class=md-nav__item> <a href=#prerequisites class=md-nav__link> Prerequisites </a> </li> <li class=md-nav__item> <a href=#creating-our-aggregators class=md-nav__link> Creating our Aggregators </a> </li> <li class=md-nav__item> <a href=#using-our-aggregators class=md-nav__link> Using our Aggregators </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#conclusions class=md-nav__link> Conclusions </a> </li> <li class=md-nav__item> <a href=#reaching-out class=md-nav__link> Reaching out </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=using-the-spark-aggregator-class-in-scala>Using the Spark Aggregator class in Scala<a class=headerlink href=#using-the-spark-aggregator-class-in-scala title="Permanent link">&para;</a></h1> <p><em>Tags: Spark, Scala, Aggregator, Machine Learning, Dataset, DataFrame, Count Distinct</em></p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>If you already understand the <code class=codehilite><span class=err>Aggregator</span></code> class and simply want to view an example of how it's implemented in Scala, feel free to skip to the <a href=#using-our-aggregators>"Using our Aggregators"</a> section.</p> </div> <h2 id=type-safe-aggregations>Type-safe Aggregations<a class=headerlink href=#type-safe-aggregations title="Permanent link">&para;</a></h2> <h3 id=what-are-they>What are they?<a class=headerlink href=#what-are-they title="Permanent link">&para;</a></h3> <p>You're in an airport waiting for your luggage at the baggage claim. The internal turmoil is rising inside of you, as most other passengers have received their luggage by now and you sure don't want to lose your clothes, your toilettries, or that bottle of deluxe craft beer you checked. Just as you start to despair, you see it: a large, bright orange suitcase that is clearly yours. Gleefully, you pick it up and a smile just begins to cross your face - until you notice a drip from the zipper. And then another. And another. While the bag itself is in the same condition as it was when you checked it, its contents are soaked. You can't help but wonder, <em>When did this happen? Was it the low pressure in the plane? Did it fall off of a cart? Should I have used bubble wrap?</em> Unfortunately, you don't really have any way of knowing. Although you should have used bubble wrap.</p> <p>A similar feeling of distress occurs when a Data Scientist performs an aggregation on a Dataset in Spark, only for the contents of the output Dataset to be revealed as invalid in some way; maybe the input and output were both intact Datasets, but something about the output's content type is incorrect. The internal mechanisms of the aggregation and what went wrong can typically only be diagnosed after a significant amount of detective work. Even then, there's no guarantee that future instances of input data won't cause another issue for the aggregation.</p> <p>However, just like adding more bubble wrap to prevent a bottle breaking in your suitcase, we can create custom aggregations that are strongly typed throughout using Spark's <code class=codehilite><span class=err>Aggregator</span></code> class. This class allows a Data Scientist to specify exactly what transformations worker nodes perform, how data is combined across nodes, and what each step should entail in terms of expected input and output type. The result is an intimate knowledge of how an aggregation transformation is being performed and an automated way to diagnose any typing issues that might arise. In other words, it's a foolproof way to save your bottle of beer next time you fly.</p> <h3 id=when-to-use-them>When to use them<a class=headerlink href=#when-to-use-them title="Permanent link">&para;</a></h3> <p>Deciding whether to perform type-safe aggregations on Spark Datasets can be a difficult decision. On the one hand, it's tempting to throw caution to the wind, declare the input and output types as <code class=codehilite><span class=err>Dataset</span></code>, and call it a day. From my experience, this works for many of the exploratory and analytic instances a Data Scientist might encounter, as data and type validations can be performed on-the-fly in a notebook or scripting environment.</p> <p>On the other hand, there are instances (e.g. automated ML pipelines in production, creating an API for other Data Scientists) when you need to ensure a transformation won't be yielding unexpected and potentially errant results without warning. These are the cases when you'll want to use the <a href=https://spark.apache.org/docs/2.0.2/api/java/org/apache/spark/sql/expressions/Aggregator.html>Aggregator</a> class in Spark. This class allows a Data Scientist to identify the input, intermediate, and output types when performing some type of custom aggregation.</p> <p>I found Spark's <code class=codehilite><span class=err>Aggregator</span></code> class to be somewhat confusing when I first encountered it. There are several steps, seemingly unused parameters, and limited examples online. Most of the examples I've seen tend to outline simple use-cases like summing a collection of integers or calculating an average. While these are certainly useful for tautological purposes, they don't offer much insight into other common aggregations that one might need to perform. Thus, my aim here is to demonstrate <em>two</em> uses of the <code class=codehilite><span class=err>Aggregator</span></code> class that one might actually use in writing a data preprocessing application and break them down line-by-line.</p> <h2 id=an-aggregator-example>An <code class=codehilite><span class=err>Aggregator</span></code> example<a class=headerlink href=#an-aggregator-example title="Permanent link">&para;</a></h2> <h3 id=assumptions>Assumptions<a class=headerlink href=#assumptions title="Permanent link">&para;</a></h3> <p>Let's suppose you have the following retail data for a home improvement store</p> <table> <thead> <tr> <th>customerID</th> <th>productID</th> <th>retailCategory</th> </tr> </thead> <tbody> <tr> <td>001</td> <td>zk67</td> <td>Lighting</td> </tr> <tr> <td>001</td> <td>gg89</td> <td>Paint</td> </tr> <tr> <td>002</td> <td>gg97</td> <td>Paint</td> </tr> <tr> <td>003</td> <td>gd01</td> <td>Gardening</td> </tr> <tr> <td>003</td> <td>af83</td> <td>A.C.</td> </tr> <tr> <td>003</td> <td>af84</td> <td>A.C.</td> </tr> <tr> <td>004</td> <td>gd77</td> <td>Gardening</td> </tr> <tr> <td>004</td> <td>gd73</td> <td>Gardening</td> </tr> <tr> <td>005</td> <td>cl55</td> <td>Cleaning</td> </tr> <tr> <td>005</td> <td>zk67</td> <td>Lighting</td> </tr> </tbody> </table> <p>and want to do the following in a type-safe manner:</p> <ul> <li>provide a count of how many unique customers appear in each <code class=codehilite><span class=err>retailCategory</span></code></li> <li>collect an array of unique <code class=codehilite><span class=err>productID</span></code>s, grouped by <code class=codehilite><span class=err>retailCategory</span></code></li> <li>transform the above data into a <code class=codehilite><span class=err>Dataset</span></code> that contains the previous two steps</li> </ul> <p>Let's also suppose we want to use the following general structure for implementing our aggregators:</p> <div class=codehilite><pre><span></span><code><span class=k>case</span> <span class=k>class</span> <span class=nc>SchemaBeforeTransform</span><span class=o>(...)</span>

<span class=k>case</span> <span class=k>class</span> <span class=nc>SchemaAfterTransform</span><span class=o>(...)</span>

<span class=k>object</span> <span class=nc>DoSomething</span><span class=o>{</span>
  <span class=k>def</span> <span class=n>transformData</span> <span class=k>=</span> <span class=o>{</span>
    <span class=k>val</span> <span class=n>transformation</span> <span class=k>=</span> <span class=n>df</span>
      <span class=o>.</span><span class=n>groupByKey</span><span class=o>(</span><span class=k>_</span><span class=o>.?)</span>
      <span class=o>.</span><span class=n>agg</span><span class=o>(</span>
        <span class=nc>DoSomething</span><span class=o>.</span><span class=n>aggregator1</span><span class=o>,</span>
        <span class=nc>DoSomething</span><span class=o>.</span><span class=n>aggregator2</span>
      <span class=o>).</span><span class=n>map</span><span class=o>{</span>
        <span class=k>case</span><span class=o>(...)</span> <span class=k>=&gt;</span> <span class=nc>SchemaAfterTransform</span><span class=o>(...)</span>
      <span class=o>}</span>
  <span class=o>}</span>

  <span class=k>val</span> <span class=n>aggregator1</span><span class=o>{...}</span>
  <span class=k>val</span> <span class=n>aggregator2</span><span class=o>{...}</span>
<span class=o>}</span>
</code></pre></div> <p>Which will result in a Data Scientist calling the following API when using our library:</p> <div class=codehilite><pre><span></span><code><span class=k>val</span> <span class=n>myValue</span> <span class=k>=</span> <span class=nc>DoSomething</span><span class=o>.</span><span class=n>transformData</span><span class=o>(...)</span>
</code></pre></div> <p>Note that we are creating an object that contains the method we want to use to perform our aggregation, as well as both of our aggregators that we want to use within that method. This differs from many other examples I've seen online for two reasons. Firstly, we are attempting to create an API for a Data Scientist to use during a data preprocessing stage rather than creating a workflow to call with some <code class=codehilite><span class=err>mainApp</span></code> object. Secondly, we are building more than two aggregators used by the same transformation.</p> <h3 id=prerequisites>Prerequisites<a class=headerlink href=#prerequisites title="Permanent link">&para;</a></h3> <p>The first items on our to do list are to import the <code class=codehilite><span class=err>Aggregator</span></code> class, the <code class=codehilite><span class=err>ExpressionEncoder</span></code> class, create a <code class=codehilite><span class=err>case class</span></code> for the input data schema shown above, and create another <code class=codehilite><span class=err>case class</span></code> for our output schema:</p> <div class=codehilite><pre><span></span><code><span class=k>import</span> <span class=nn>org.apache.spark.sql.expressions.Aggregator</span>
<span class=k>import</span> <span class=nn>org.apache.spark.sql.catalyst.encoders.ExpressionEncoder</span>

<span class=c1>// input schema</span>
<span class=k>case</span> <span class=k>class</span> <span class=nc>RetailByCustomer</span><span class=o>(</span><span class=n>customerID</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span>
                            <span class=n>productID</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span>
                            <span class=n>retailCategory</span><span class=k>:</span> <span class=kt>String</span><span class=o>)</span>

<span class=c1>// output schema</span>
<span class=k>case</span> <span class=k>class</span> <span class=nc>AggRetailByCategory</span><span class=o>(</span><span class=n>retailCategory</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span>
                               <span class=n>customerCount</span><span class=k>:</span> <span class=kt>Int</span><span class=o>,</span>
                               <span class=n>productSet</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span>
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <p>We need to import the <code class=codehilite><span class=err>ExpressionEncoder</span></code> class in order to define our own encoder for a <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> type, as this is not a default encoder in scala.</p> </div> <h3 id=creating-our-aggregators>Creating our Aggregators<a class=headerlink href=#creating-our-aggregators title="Permanent link">&para;</a></h3> <p>Now we get to write our aggregators. I'll show both of them in full now and then break them down line-by-line.</p> <div class=codehilite><pre><span></span><code><span class=c1>// Counting unique customers in the dataset</span>
<span class=k>val</span> <span class=n>distinctCustomerCountAggregator</span><span class=k>:</span> <span class=kt>TypedColumn</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Int</span><span class=o>]</span> <span class=k>=</span>
  <span class=k>new</span> <span class=nc>Aggregator</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span><span class=p>,</span> <span class=kt>Int</span><span class=o>]</span> <span class=o>{</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>zero</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=nc>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]()</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>reduce</span><span class=o>(</span><span class=n>es</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>rbc</span><span class=k>:</span> <span class=kt>RetailByCustomer</span><span class=o>)</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>es</span> <span class=o>+</span> <span class=n>rbc</span><span class=o>.</span><span class=n>customerID</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>merge</span><span class=o>(</span><span class=n>wx</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>wy</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>wx</span><span class=o>.</span><span class=n>union</span><span class=o>(</span><span class=n>wy</span><span class=o>)</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>finish</span><span class=o>(</span><span class=n>reduction</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>reduction</span><span class=o>.</span><span class=n>size</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>bufferEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
      <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>outputEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
      <span class=n>implicitly</span><span class=o>(</span><span class=nc>Encoders</span><span class=o>.</span><span class=n>scalaInt</span><span class=o>)</span>
  <span class=o>}</span>

<span class=c1>// Creating an array of productIDs from the dataset</span>
<span class=k>val</span> <span class=n>productIDAggregator</span><span class=k>:</span> <span class=kt>TypedColumn</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
  <span class=k>new</span> <span class=nc>Aggregator</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=o>{</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>zero</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=nc>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]()</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>reduce</span><span class=o>(</span><span class=n>es</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>rbc</span><span class=k>:</span> <span class=kt>RetailByCustomer</span><span class=o>)</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>es</span> <span class=o>+</span> <span class=n>rbc</span><span class=o>.</span><span class=n>productID</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>merge</span><span class=o>(</span><span class=n>wx</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>wy</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span>
      <span class=n>wx</span><span class=o>.</span><span class=n>union</span><span class=o>(</span><span class=n>wy</span><span class=o>)</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>finish</span><span class=o>(</span><span class=n>reduction</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>reduction</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>bufferEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
      <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>

    <span class=k>override</span> <span class=k>def</span> <span class=n>outputEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
      <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>
  <span class=o>}</span>
</code></pre></div> <p>As you might infer from the value name, our first aggregator provides a count of distinct customers. This is done by adding each customer to a <code class=codehilite><span class=err>Set</span></code>, as sets only include one instance of any given value. It's also important to use a distinct count in this scenario in order to avoid overcounting in situations where incoming data may include duplicates or <code class=codehilite><span class=err>productID</span></code> values that don't map to any <code class=codehilite><span class=err>retailCAtegory</span></code>. Now, let's take a look at the first line:</p> <div class=codehilite><pre><span></span><code><span class=k>val</span> <span class=n>distinctCustomerCountAggregator</span><span class=k>:</span> <span class=kt>TypedColumn</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Int</span><span class=o>]</span> <span class=k>=</span>
  <span class=k>new</span> <span class=nc>Aggregator</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span><span class=p>,</span> <span class=kt>Int</span><span class=o>]</span> <span class=o>{</span>
</code></pre></div> <p>Here we are declaring a value that will return a <a href=https://spark.apache.org/docs/2.2.1/api/java/org/apache/spark/sql/TypedColumn.html>TypedColumn</a> with the expected input (<code class=codehilite><span class=err>RetailByCustomer</span></code> - an <a href=https://jaceklaskowski.gitbooks.io/mastering-spark-sql/spark-sql-Expression.html>Expression</a>) and the expected output (<code class=codehilite><span class=err>Int</span></code> - an <a href=https://jaceklaskowski.gitbooks.io/mastering-spark-sql/spark-sql-ExpressionEncoder.html>ExpressionEncoder</a>). We're setting this value equal to a new <code class=codehilite><span class=err>Aggregator</span></code> and defining the input type (<code class=codehilite><span class=err>RetailByCustomer</span></code>), the intermediate type (<code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code>), and the output type (<code class=codehilite><span class=err>Int</span></code>). That is, this Aggregator will expect to take in some type defined in our <code class=codehilite><span class=err>RetailByCustomer</span></code> case class, perform some type of transformation that will result in a <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> type, and return some value of type <code class=codehilite><span class=err>Int</span></code> after aggregation.</p> <p>Now onto the meat of the function. If you're reading this article, you probably know that Spark is a framework for performing data transformations in a distributed fashion, so you probably know that there is a master node that sends out tasks to worker node executors to perform data transformations. But what tasks do you send to the worker nodes to work together when performing an aggregation across the entire dataset?</p> <p>The way I like to think about it at a <em>high level</em> starts with individual worker nodes. The <code class=codehilite><span class=err>Aggregator</span></code> class sends tasks to an executor on an individual worker node (and all other worker nodes active for the job) on how to begin an aggregation:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>zero</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=nc>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]()</span>
</code></pre></div> <p>That is, in our case, each worker node should start the aggregation with an empty set of type <code class=codehilite><span class=err>String</span></code>.</p> <p>Next, the <code class=codehilite><span class=err>Aggregator</span></code> class tells each worker node what to do with the data it has in memory:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>reduce</span><span class=o>(</span><span class=n>es</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>rbc</span><span class=k>:</span> <span class=kt>RetailByCustomer</span><span class=o>)</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span>
  <span class=n>es</span> <span class=o>+</span> <span class=n>rbc</span><span class=o>.</span><span class=n>customerID</span>
</code></pre></div> <p>The instructions in our <code class=codehilite><span class=err>reduce</span></code> definition are telling each worker node to expect inputs of <code class=codehilite><span class=err>es</span></code>, our "empty set" from the previous step, and <code class=codehilite><span class=err>rbc</span></code>, our <code class=codehilite><span class=err>RetailByCustomer</span></code> case class defined above. Additionally, the output of this transformation on each worker node is going to result in an expected type <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code>. Lastly, the actual transformation to take place on each worker node is defined. Each in-memory value stored as a type <code class=codehilite><span class=err>RetailByCustomer.customerID</span></code> (which we defined as a <code class=codehilite><span class=err>String</span></code>) is added to the existing empty set, resulting in a <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> containing distinct customer IDs.</p> <p>To see this in practice, suppose our data has been partitioned by <code class=codehilite><span class=err>retailCategory</span></code>, such that information about "Lighting" and "Gardening" is stored on one worker node, "A.C." and "Cleaning" are stored on a second node, and "Paint" is stored on a third node. The resulting sets on each node should look like:</p> <table> <thead> <tr> <th></th> <th>Worker 1</th> <th>Worker 2</th> <th>Worker 3</th> </tr> </thead> <tbody> <tr> <td>Input <code class=codehilite><span class=err>es</span></code></td> <td>Set()</td> <td>Set()</td> <td>Set()</td> </tr> <tr> <td>Input <code class=codehilite><span class=err>rbc</span></code></td> <td>"001", "005", "003", "004", "004"</td> <td>"003", "003", "005"</td> <td>"001", "002"</td> </tr> <tr> <td>Output <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code></td> <td>Set("001", "005", "003", "004")</td> <td>Set("003", "005")</td> <td>Set("001", "002")</td> </tr> </tbody> </table> <p>Now that the transformation of finding unique <code class=codehilite><span class=err>customerID</span></code>s has been performed on each worker node, the <code class=codehilite><span class=err>Aggregator</span></code> class has to instruct the worker nodes how to interact with each other in order to find unique <code class=codehilite><span class=err>customerID</span></code>s <em>across</em> nodes. This brings us to the <code class=codehilite><span class=err>merge</span></code> definition:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>merge</span><span class=o>(</span><span class=n>wx</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>wy</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>wx</span><span class=o>.</span><span class=n>union</span><span class=o>(</span><span class=n>wy</span><span class=o>)</span>
</code></pre></div> <p>Here, we are defining the two expected inputs as type <code class=codehilite><span class=err>Set[String</span></code>]; one from "Worker X" (<code class=codehilite><span class=err>wx</span></code>) and one from "Worker Y" (<code class=codehilite><span class=err>wy</span></code>). Again, we define the expected output type as <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code>. Lastly, the <code class=codehilite><span class=err>Aggregator</span></code> class has to give instructions on what each worker node should do when interacting with the others. In this case, we tell each worker to union the output from the <code class=codehilite><span class=err>reduce</span></code> step with the other worker's <code class=codehilite><span class=err>reduce</span></code> output (i.e. return all elements between the two sets).</p> <p>While there's much more nuance to how information is passed across worker nodes, for the purposes of understanding the <code class=codehilite><span class=err>Aggregator</span></code> class we can visualize the output of the <code class=codehilite><span class=err>merge</span></code> step as follows:</p> <table> <thead> <tr> <th></th> <th>Worker 1</th> <th>Worker 2</th> <th>Worker 3</th> </tr> </thead> <tbody> <tr> <td>Worker 1</td> <td>-</td> <td>Set("001", "005", "003", "004")</td> <td>Set("001", "005", "003", "004", "002")</td> </tr> <tr> <td>Worker 2</td> <td>-</td> <td>-</td> <td>Set("003", "005", "001", "002")</td> </tr> <tr> <td>Worker 3</td> <td>-</td> <td>-</td> <td>-</td> </tr> </tbody> </table> <p>which will result in the output <code class=codehilite><span class=err>Set(&quot;001&quot;, &quot;005&quot;, &quot;003&quot;, &quot;004&quot;, &quot;002&quot;)</span></code> of type <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code>.</p> <p>The next step, <code class=codehilite><span class=err>finish</span></code>, provides instructions for the driver to perform an action:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>finish</span><span class=o>(</span><span class=n>reduction</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>reduction</span><span class=o>.</span><span class=n>size</span>
</code></pre></div> <p>Here, we define the expected input type as our unioned <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> and expected output type as <code class=codehilite><span class=err>Int</span></code>. We also define the action to be taken on the <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> input by calling <code class=codehilite><span class=err>size</span></code>, which returns an integer representing the number of items in the set. In the case of our example, this returns <code class=codehilite><span class=err>5</span></code>.</p> <p>The last step is to define the <code class=codehilite><span class=err>Encoder</span></code> for both our buffer (or intermediate) step and output step:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>bufferEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
  <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>

<span class=k>override</span> <span class=k>def</span> <span class=n>outputEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Int</span><span class=o>]</span> <span class=k>=</span>
  <span class=n>implicitly</span><span class=o>(</span><span class=nc>Encoders</span><span class=o>.</span><span class=n>scalaInt</span><span class=o>)</span>
</code></pre></div> <p>The output for <code class=codehilite><span class=err>distinctCustomerCountAggregator</span></code> is an <code class=codehilite><span class=err>Int</span></code>, which has a predefined encoder in Scala. Thus, we can simply call <code class=codehilite><span class=err>Encoders.scalaInt</span></code> when defining our <code class=codehilite><span class=err>outputEncoder</span></code> and pass it implicitly to the other definitions. However, although both <code class=codehilite><span class=err>Set</span></code> and <code class=codehilite><span class=err>String</span></code> have predefined encoders in Scala, <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> does not. Therefore, we have to define our own <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> encoder using the <code class=codehilite><span class=err>ExpressionEncoder</span></code> class that was imported in the first step.</p> <p><code class=codehilite><span class=err>productIDAggregator</span></code> is actually quite similar to the <code class=codehilite><span class=err>distinctCustomerCountAggregator</span></code> except for one key difference: we are expecting an output of type <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> rather than <code class=codehilite><span class=err>Int</span></code>. This will change a couple of the steps.</p> <div class="admonition exercise"> <p class=admonition-title>Exercise</p> <p>I encourage you to think which steps will need to be changed in order to facilitate this before continuing (hint: there are 3).</p> </div> <p>The first difference involves changing both the <code class=codehilite><span class=err>TypedColumn</span></code> and expected <code class=codehilite><span class=err>Aggregator</span></code> output types to <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code>:</p> <div class=codehilite><pre><span></span><code><span class=k>val</span> <span class=n>productIDAggregator</span><span class=k>:</span> <span class=kt>TypedColumn</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
  <span class=k>new</span> <span class=nc>Aggregator</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span>
</code></pre></div> <p>The next three steps are actually the same for both aggregators: we instruct the worker nodes to create empty sets, add <code class=codehilite><span class=err>productID</span></code>s to those sets, and union the resulting sets across themselves.</p> <p>The second difference, however, appears in the <code class=codehilite><span class=err>finish</span></code> definition. We want to change the expected output type from <code class=codehilite><span class=err>Int</span></code> to <code class=codehilite><span class=k>Set</span><span class=o>[</span><span class=n>String</span><span class=o>]</span><span class=w></span></code> and eliminate the <code class=codehilite><span class=err>size</span></code> method, as we just want to return the actual set of <code class=codehilite><span class=err>productID</span></code>s:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>finish</span><span class=o>(</span><span class=n>reduction</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>reduction</span>
</code></pre></div> <p>Lastly, we need to change the <code class=codehilite><span class=err>outputEncoder</span></code>. Since we're not really transforming between types in this case, our <code class=codehilite><span class=err>bufferEncoder</span></code> and <code class=codehilite><span class=err>outputEncoder</span></code> will be the same:</p> <div class=codehilite><pre><span></span><code><span class=k>override</span> <span class=k>def</span> <span class=n>bufferEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
  <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>

<span class=k>override</span> <span class=k>def</span> <span class=n>outputEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span>
  <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>
</code></pre></div> <p>And that's it! We've created two aggregators that perform two distinct functions!</p> <h3 id=using-our-aggregators>Using our Aggregators<a class=headerlink href=#using-our-aggregators title="Permanent link">&para;</a></h3> <p>To use these in practice, let's take a look at the full code:</p> <div class=codehilite><pre><span></span><code><span class=k>import</span> <span class=nn>org.apache.spark.sql.</span><span class=o>{</span><span class=nc>DataFrame</span><span class=o>,</span> <span class=nc>Dataset</span><span class=o>}</span>
<span class=k>import</span> <span class=nn>org.apache.spark.sql.expressions.Aggregator</span>
<span class=k>import</span> <span class=nn>org.apache.spark.sql.catalyst.encoders.ExpressionEncoder</span>

<span class=c1>// input schema</span>
<span class=k>case</span> <span class=k>class</span> <span class=nc>RetailByCustomer</span><span class=o>(</span><span class=n>customerID</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span> <span class=n>productID</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span> <span class=n>retailCategory</span><span class=k>:</span> <span class=kt>String</span><span class=o>)</span>

<span class=c1>// output schema</span>
<span class=k>case</span> <span class=k>class</span> <span class=nc>AggRetailByCategory</span><span class=o>(</span><span class=n>retailCategory</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span> <span class=n>customerCount</span><span class=k>:</span> <span class=kt>Int</span><span class=o>,</span> <span class=n>productSet</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span>

<span class=c1>// object that holds our specific data transformation method</span>
<span class=k>object</span> <span class=nc>PreprocessData</span><span class=o>{</span>
  <span class=c1>// data transformation we want to perform</span>
  <span class=c1>// note the typing of the df parameter and expected output</span>
  <span class=k>def</span> <span class=n>createArrayAndCount</span><span class=o>(</span><span class=n>df</span><span class=k>:</span> <span class=kt>Dataset</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=o>])</span><span class=k>:</span> <span class=kt>Dataset</span><span class=o>[</span><span class=kt>AggRetailByCategory</span><span class=o>]</span> <span class=k>=</span> <span class=o>{</span>
    <span class=k>val</span> <span class=n>transformedData</span><span class=k>:</span> <span class=kt>Dataset</span><span class=o>[</span><span class=kt>AggRetailByCategory</span><span class=o>]</span> <span class=k>=</span>
      <span class=c1>// using a groupByKey method to group by any Dataset with type defined as &#39;retailCategory&#39;</span>
      <span class=n>df</span><span class=o>.</span><span class=n>groupByKey</span><span class=o>(</span><span class=k>_</span><span class=o>.</span><span class=n>retailCategory</span><span class=o>)</span>
      <span class=o>.</span><span class=n>agg</span><span class=o>(</span>
        <span class=c1>// our aggregator functions at work</span>
        <span class=nc>PreprocessData</span><span class=o>.</span><span class=n>distinctCustomerCountAggregator</span><span class=o>.</span><span class=n>name</span><span class=o>(</span><span class=s>&quot;customerCount&quot;</span><span class=o>),</span>
        <span class=nc>DoSomething</span><span class=o>.</span><span class=n>productIDAggregator</span><span class=o>.</span><span class=n>name</span><span class=o>(</span><span class=s>&quot;productIDs&quot;</span><span class=o>)</span>
      <span class=o>).</span><span class=n>map</span><span class=o>{</span>
        <span class=c1>// retailCategory(rc), customerCount(cc), productSet(ps)</span>
        <span class=k>case</span><span class=o>(</span><span class=n>rc</span><span class=k>:</span> <span class=kt>String</span><span class=o>,</span> <span class=n>cc</span><span class=k>:</span> <span class=kt>Int</span><span class=o>,</span> <span class=n>ps</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span> <span class=k>=&gt;</span> <span class=nc>AggRetailByCategory</span><span class=o>(</span><span class=n>rc</span><span class=o>,</span> <span class=n>cc</span><span class=o>,</span> <span class=n>ps</span><span class=o>)</span>
      <span class=o>}</span>
    <span class=n>transformedData</span>
  <span class=o>}</span>

  <span class=k>val</span> <span class=n>distinctCustomerCountAggregator</span><span class=k>:</span> <span class=kt>TypedColumn</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Int</span><span class=o>]</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>Aggregator</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span><span class=p>,</span> <span class=kt>Int</span><span class=o>]</span> <span class=o>{</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>zero</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=nc>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]()</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>reduce</span><span class=o>(</span><span class=n>es</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>rbc</span><span class=k>:</span> <span class=kt>RetailByCustomer</span><span class=o>)</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>es</span> <span class=o>+</span> <span class=n>rbc</span><span class=o>.</span><span class=n>customerID</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>merge</span><span class=o>(</span><span class=n>wx</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>wy</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>wx</span><span class=o>.</span><span class=n>union</span><span class=o>(</span><span class=n>wy</span><span class=o>)</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>finish</span><span class=o>(</span><span class=n>reduction</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Int</span> <span class=o>=</span> <span class=n>reduction</span><span class=o>.</span><span class=n>size</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>bufferEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span> <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>outputEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span> <span class=n>implicitly</span><span class=o>(</span><span class=nc>Encoders</span><span class=o>.</span><span class=n>scalaInt</span><span class=o>)</span>
    <span class=o>}.</span><span class=n>toColumn</span>

  <span class=c1>// Creating an array of productIDs from the dataset</span>
  <span class=k>val</span> <span class=n>productIDAggregator</span><span class=k>:</span> <span class=kt>TypedColumn</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span> <span class=k>new</span> <span class=nc>Aggregator</span><span class=o>[</span><span class=kt>RetailByCustomer</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span><span class=p>,</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=o>{</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>zero</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=nc>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]()</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>reduce</span><span class=o>(</span><span class=n>es</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>rbc</span><span class=k>:</span> <span class=kt>RetailByCustomer</span><span class=o>)</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>es</span> <span class=o>+</span> <span class=n>rbc</span><span class=o>.</span><span class=n>productID</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>merge</span><span class=o>(</span><span class=n>wx</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>],</span> <span class=n>wy</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>wx</span><span class=o>.</span><span class=n>union</span><span class=o>(</span><span class=n>wy</span><span class=o>)</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>finish</span><span class=o>(</span><span class=n>reduction</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>])</span><span class=k>:</span> <span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]</span> <span class=k>=</span> <span class=n>reduction</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>bufferEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span> <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>
    <span class=k>override</span> <span class=k>def</span> <span class=n>outputEncoder</span><span class=k>:</span> <span class=kt>Encoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]]</span> <span class=k>=</span> <span class=n>implicitly</span><span class=o>(</span><span class=nc>ExpressionEncoder</span><span class=o>[</span><span class=kt>Set</span><span class=o>[</span><span class=kt>String</span><span class=o>]])</span>
    <span class=o>}.</span><span class=n>toColumn</span>
<span class=o>}</span>
</code></pre></div> <p>After publishing the code above, a Data Scientist can call the following when building a data transformation pipeline:</p> <div class=codehilite><pre><span></span><code><span class=k>import</span> <span class=nn>com.wherever.code.is.PreprocessData</span>

<span class=c1>//customerID  productID | retailCategory |</span>
<span class=k>val</span> <span class=n>retailData</span> <span class=k>=</span> <span class=nc>Seq</span><span class=o>(</span>
<span class=o>(</span><span class=s>&quot;001&quot;</span><span class=o>,</span> <span class=s>&quot;zk67&quot;</span><span class=o>,</span> <span class=s>&quot;Lighting&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;001&quot;</span><span class=o>,</span> <span class=s>&quot;gg89&quot;</span><span class=o>,</span> <span class=s>&quot;Paint&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;002&quot;</span><span class=o>,</span> <span class=s>&quot;gg97&quot;</span><span class=o>,</span> <span class=s>&quot;Paint&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;003&quot;</span><span class=o>,</span> <span class=s>&quot;gd01&quot;</span><span class=o>,</span> <span class=s>&quot;Gardening&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;003&quot;</span><span class=o>,</span> <span class=s>&quot;af83&quot;</span><span class=o>,</span> <span class=s>&quot;A.C.&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;003&quot;</span><span class=o>,</span> <span class=s>&quot;af84&quot;</span><span class=o>,</span> <span class=s>&quot;A.C.&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;004&quot;</span><span class=o>,</span> <span class=s>&quot;gd77&quot;</span><span class=o>,</span> <span class=s>&quot;Gardening&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;004&quot;</span><span class=o>,</span> <span class=s>&quot;gd73&quot;</span><span class=o>,</span> <span class=s>&quot;Gardening&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;005&quot;</span><span class=o>,</span> <span class=s>&quot;cl55&quot;</span><span class=o>,</span> <span class=s>&quot;Cleaning&quot;</span><span class=o>)</span>
<span class=o>(</span><span class=s>&quot;005&quot;</span><span class=o>,</span> <span class=s>&quot;zk67&quot;</span><span class=o>,</span> <span class=s>&quot;Lighting&quot;</span><span class=o>)</span>
<span class=o>).</span><span class=n>toDF</span><span class=o>(</span><span class=s>&quot;customerID&quot;</span><span class=o>,</span> <span class=s>&quot;productID&quot;</span><span class=o>,</span> <span class=s>&quot;retailCategory&quot;</span><span class=o>)</span>

<span class=k>val</span> <span class=n>transformedRetailData</span> <span class=k>=</span> <span class=nc>PreprocessData</span><span class=o>.</span><span class=n>createArrayAndCount</span><span class=o>(</span><span class=n>retailData</span><span class=o>)</span>
</code></pre></div> <p>where <code class=codehilite><span class=err>val transformedRetailData</span></code> should look something like</p> <table> <thead> <tr> <th>retailCategory</th> <th align=center>customerCount</th> <th>productSet</th> </tr> </thead> <tbody> <tr> <td>Lighting</td> <td align=center>2</td> <td>Set("zk67")</td> </tr> <tr> <td>Gardening</td> <td align=center>2</td> <td>Set("gd01", "gd77", "gd73")</td> </tr> <tr> <td>Paint</td> <td align=center>2</td> <td>Set("gg89", "gg97")</td> </tr> <tr> <td>A.C.</td> <td align=center>1</td> <td>Set("af83", "af84")</td> </tr> <tr> <td>Cleaning</td> <td align=center>1</td> <td>Set("cl55")</td> </tr> </tbody> </table> <h2 id=conclusions>Conclusions<a class=headerlink href=#conclusions title="Permanent link">&para;</a></h2> <ul> <li>Type-safe aggregations allow Data Scientists to specify how transformations are being undertaken, how data is combined within and across nodes, and what each step should entail in terms of expected input and output type.</li> <li>Use Spark's <code class=codehilite><span class=err>Aggregator</span></code> class to perform type-safe transformations. The typical use-case is in a production-level environment, writing an API, or when you plan on repeated use of an aggregation.</li> <li>Understanding what is happening under the hood in Spark at a high level is important in understanding how the <code class=codehilite><span class=err>Aggregator</span></code> class works.</li> </ul> <h2 id=reaching-out>Reaching out<a class=headerlink href=#reaching-out title="Permanent link">&para;</a></h2> <p>Thanks for reading this article! Please feel free to reach out with any comments/questions via <a href=https://twitter.com/martainyo>Twitter</a> or by commenting on the <a href=medium.com>Medium Post</a>. I'm constantly learning and looking to improve my knowledge of all things Data Science, so if I've made any erroneous statements or you know of a better methodology than the one in this article, please let me know!!</p> <div class=footer> &copy; 2020 Martin Jackson </div> </article> </div> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Martin Jackson </div> powered by <a href=https://www.mkdocs.org target=_blank rel=noopener>MkDocs</a> and <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs</a> </div> <div class=md-footer-social> <link rel=stylesheet href=../../assets/fonts/font-awesome.css> <a href=https://www.linkedin.com/in/martinjacksonds/ target=_blank rel=noopener title=linkedin class="md-footer-social__link fa fa-linkedin"></a> <a href=https://www.github.com/mfjackson target=_blank rel=noopener title=github class="md-footer-social__link fa fa-github"></a> <a href=https://www.medium.com target=_blank rel=noopener title=medium class="md-footer-social__link fa fa-medium"></a> </div> </div> </div> </footer> </div> <script src=../../assets/javascripts/application.c33a9706.js></script> <script>app.initialize({version:"1.1",url:{base:"../.."}})</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>